3-13. Let *A[1..n]* be an array of real numbers. Design an algorithm to perform any sequence of the following operations:

 * *Add(i,y)* -- Add the value *y* to the ith number.
 * *Partial-sum(i)* -- Return the sum of the first *i* numbers, i.e. *âˆ‘<sub>j=1</sub><sup>i</sup>A[j]*. There are no insertions or deletions; the only change is to the values of the numbers. Each operation should take *O(logn)* steps. You may use one additional array of size *n* as a work space.

**Solution** 

This would require a tree that can be constructed by going through the array and putting the elements at their locations. The cumulative sum of elements is also put into the additional work space array.

For example if the array is [1,2,3,4]; then the workspace array would contain [1,3,6,10]. Thus the value of any number can be retrieved by subtracting its value from the preceding value in the work array. E.g. value at index 4 is 10 - 6 = 4. Similarly, the entries to the workspace are built by adding the array entry to the preceding cumulative sum.

The tree is needed for *O(logn)* lookup and a sample schema that comes to mind is to build a balanced binary tree with the following assumptions:

 * The root of the tree is array index 0.
 * All odd array index values end up on the left child branch and all even array index values end up on the right.
 * If a node has no left child, assign the value to the left; otherwise add a new right child. If it already has both, 
 * The lookup formula to retrieve an element at a location is thus
 
    * If odd, choose the left branch; otherwise choose the right
    * If the index value is >= twice the value of the right child, then go down the right branch
    * 
